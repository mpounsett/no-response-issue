<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE rfc SYSTEM 'rfc2629.dtd' []>
<rfc ipr="trust200902" category="bcp" docName="draft-ietf-dnsop-no-response-issue-05">
<?rfc toc="yes"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes"?>
<?rfc compact="yes"?>
<?rfc subcompact="no"?>
<?rfc private=""?>
<?rfc topblock="yes"?>
<?rfc comments="no"?>
<front>
<title abbrev="Failure To Respond">A Common Operational Problem in DNS Servers - Failure To Respond.</title>

<author initials="M." surname="Andrews" fullname="M. Andrews">
<organization abbrev="ISC">Internet Systems Consortium</organization>
<address>
<postal>
<street></street>
<city></city>
<code></code>
<country></country>
<region></region>
</postal>
<phone></phone>
<email>marka@isc.org</email>
<uri></uri>
</address>
</author>
<date year="2016" month="September" day="18"/>

<area>OPS</area>
<workgroup></workgroup>


<abstract>
<t>The DNS is a query / response protocol.  Failure to respond or to respond
correctly to queries causes both immediate operational problems and long term
problems with protocol development.
</t>
<t>This document identifies a number of common kinds of queries which some
servers either fail to respond or else respond incorrectly.  This document
also suggests procedures for TLD and other zone operators to apply to help
reduce / eliminate the problem.
</t>
<t>The document does not look at the DNS data itself, just the structure of the
responses.
</t>
</abstract>


</front>

<middle>

<section anchor="introduction" title="Introduction">
<t>The DNS <xref target="RFC1034"/>, <xref target="RFC1035"/> is a query / response protocol.  Failure to
respond to queries or to respond incorrectly causes both immediate operational
problems and long term problems with protocol development.
</t>
<t>Failure to respond to a query is indistinguishable from a packet loss.
Without doing a analysis of query response patterns will results in
unnecessary additional queries being made by DNS clients, and delays being
introduced to the resolution process.
</t>
<t>Due to the inability to distinguish between packet loss and nameservers
dropping EDNS <xref target="RFC6891"/> queries, packet loss is sometimes misclassified as
lack of EDNS support which can lead to DNSSEC validation failures.
</t>
<t>Servers which fail to respond to queries to remain results in developers being
hesitant to deploy new standards.  Such servers need to be identified.
</t>
<t>The DNS has response codes that cover almost any conceivable query response.
A nameserver should be able to respond to any conceivable query using them.
</t>
<t>Unless a nameserver is under attack, it should respond to all queries directed
to it.  Additionally, the nameserver should not assume that there isn't a
delegation to the server even if it is not configured to serve the zone.
Broken nameservers are a common occurrence in the DNS and receiving queries
for zones that the server is not configured for is not necessarily an
indication that the server is under attack.  Parent zone operators are
supposed to regularly check that the delegating NS records are consistent with
those of the delegated zone and to correct them when they are not <xref target="RFC1034"/>.
Doing this regularly should reduce the instances of broken delegations.
</t>
<t>When a nameserver is under attack it may wish to drop packets.  A common
attack is to use a nameserver as a amplifier by sending spoofed packets.  This
is done because response packets are bigger than the queries and big
amplification factors are available especially if EDNS is supported.  Limiting
the rate of responses is reasonable when this is occurring and the client
should retry.  This however only works if legitimate clients are not being
forced to guess whether EDNS queries are accepted or not.  While there is
still a pool of servers that don't respond to EDNS requests, clients have no
way to know if the lack of response is due to packet loss, EDNS packets not
being supported or rate limiting due to the server being under attack.
Mis-classifications of server characteristics are unavoidable when rate
limiting is done.
</t>
</section>

<section anchor="consequences" title="Consequences">
<t>Lack of following the relevant RFCs has lead to various consequences.  Some as
a direct result and some from recursive servers try to work around the non
compliance.  Fixing known issues know will reduce future consequences as DNS
clients make use of the features available in the DNS protocol.
</t>
<t>The AD flag bit in a response cannot be trusted to mean anything as servers
incorrectly copied the flag bit from the request to the response despite the
prohibition.
</t>
<t>Wide spread non response to EDNS queries has lead to recursive servers having
to assume EDNS may not supported and fallback to plain DNS is required.
Servers get incorrectly diagnosed as not supporting EDNS and when they also
serve signed zones DNSSEC validation fails.
</t>
<t>Similarly, wide spread non response to EDNS options, requires recursive
servers to have to decide whether to probe to see if it is the EDNS option or
just EDNS that is causing the non response.  In the limited amount of time
required to resolve a query before the client times out this is not possible.
</t>
<t>Similarly, incorrectly returning FORMERR to a EDNS option being present, leads
to the recursive server not being able to determine if the server is just
broken in the handling of the EDNS option or doesn't support EDNS at all.
</t>
<t>The consequences of servers not following the RFCs will only expand if
measures are not put in place to remove non compliant servers from the
ecosystem.  Working around issues due to non RFC compliance is not
sustainable.
</t>
</section>

<section anchor="common-queries-kinds-that-result-in-non-responses" title="Common queries kinds that result in non responses.">
<t>There are a number common query kinds that fail to respond today.  They are:
EDNS queries with and without extensions; queries for unknown (unallocated) or
unsupported types; and filtering of TCP queries.
</t>

<section anchor="basic-dns-queries" title="Basic DNS Queries">

<section anchor="zone-existence" title="Zone Existence">
<t>Initially to test existence of the zone, an SOA query should be made.  If the
SOA record is not returned but some other response is returned, this is a
indication of a bad delegation. If the server fails to get a response to a SOA
query, the  Operator should make an A query for the zone, as some nameservers
fail to respond to SOA queries but will respond to A queries.
</t>
</section>

<section anchor="unknown--unsupported-type-queries" title="Unknown / Unsupported Type Queries">
<t>Identifying servers that fail to respond to unknown or unsupported types can
be done by making an initial DNS query for an A record, making a number of
queries for an unallocated type, then making a query for an A record again.
IANA maintains a registry of allocated types.
</t>
<t>If the server responds to the first and last queries but fails to respond to
the queries for the unallocated type, it is probably faulty.  The test should
be repeated a number of times to eliminate the likelihood of a false positive
due to packet loss.
</t>
</section>

<section anchor="dns-flags" title="DNS Flags">
<t>Some servers fail to respond to DNS queries with various DNS flags set,
regardless of whether they are defined or still reserved.  At the time of
writing there are servers that fail to respond to queries with the AD bit set
to 1 and servers that fail to respond to queries with the last reserved flag
bit set.
</t>
</section>

<section anchor="unknown-dns-opcodes" title="Unknown DNS opcodes">
<t>The use of previously undefined opcodes is to be expected.  Since the DNS was
first defined two new opcodes have been added, UPDATE and NOTIFY.
</t>
<t>NOTIMP is the expected rcode to an unknown or unimplemented opcode.
</t>
<t>Note: while new opcodes will most probably use the current layout structure
for the rest of the message there is no requirement that anything other than
the DNS header match.
</t>
</section>

<section anchor="tcp-queries" title="TCP Queries">
<t>All DNS servers are supposed to respond to queries over TCP <xref target="RFC7766"/>.
Firewalls that drop TCP connection attempts, they should reset the connect
attempt or send a ICMP/ICMPv6 administratively prohibited message. Dropping
TCP connections introduces excessive delays to the resolution process.
</t>
<t>Whether a server accepts TCP connections can be tested by first checking that
it responds to UDP queries to confirm that it is up and operating, then
attempting the same query over TCP.  An additional query should be made over
UDP if the TCP connection attempt fails to confirm that the server under test
is still operating.
</t>
</section>
</section>

<section anchor="edns-queries" title="EDNS Queries">

<section anchor="edns-queries--version-independent" title="EDNS Queries - Version Independent">
<t>Identifying servers that fail to respond to EDNS queries can be done by first
identifying that the server responds to regular DNS queries, followed by a
series of otherwise identical queries using EDNS, then making the original
query again.  A series of EDNS queries is needed as at least one DNS
implementation responds to the first EDNS query with FORMERR but fails to
respond to subsequent queries from the same address for a period until a
regular DNS query is made.  The EDNS query should specify a UDP buffer size of
512 bytes to avoid false classification of not supporting EDNS due to response
packet size.
</t>
<t>If the server responds to the first and last queries but fails to respond to
most or all of the EDNS queries, it is probably faulty.  The test should be
repeated a number of times to eliminate the likelihood of a false positive due
to packet loss.
</t>
<t>Firewalls may also block larger EDNS responses but there is no easy way to
check authoritative servers to see if the firewall is mis-configured.
</t>
</section>

<section anchor="edns-queries--version-specific" title="EDNS Queries - Version Specific">
<t>Some servers respond correctly to EDNS version 0 queries but fail to respond
to EDNS queries with version numbers that are higher than zero.  Servers
should respond with BADVERS to EDNS queries with version numbers that they do
not support.
</t>
<t>Some servers respond correctly to EDNS version 0 queries but fail to set QR=1
when responding to EDNS versions they do not support.  Such answers are
discarded or treated as requests.
</t>
</section>

<section anchor="edns-options" title="EDNS Options">
<t>Some servers fail to respond to EDNS queries with EDNS options set.  Unknown
EDNS options are supposed to be ignored by the server <xref target="RFC6891"/>.
</t>
</section>

<section anchor="edns-flags" title="EDNS Flags">
<t>Some servers fail to respond to EDNS queries with EDNS flags set.  Server
should ignore EDNS flags they do not understand and should not add them to the
response <xref target="RFC6891"/>.
</t>
</section>

<section anchor="dnssec" title="DNSSEC">
<t>Servers should be checked to see if they support DNSSEC.  Servers should also
be checked to see if they support DNSSEC with EDNS.
</t>
</section>
</section>
</section>

<section anchor="remediating" title="Remediating">
<t>While the first step in remediating this problem is to get the offending
nameserver code corrected, there is a very long tail problem with DNS servers
in that it can often take over a decade between the code being corrected and a
nameserver being upgraded with corrected code.  With that in mind it is
requested that TLD, and other similar zone operators, take steps to identify
and inform their customers, directly or indirectly through registrars, that
they are running such servers and that the customers need to correct the
problem.
</t>
<t>TLD operators are being asked to do this as they, due to the nature of running
a TLD and the hierarchical nature of the DNS, have access to a large numbers
of nameserver names as well as contact details for the registrants of those
nameservers.  While it is possible to construct lists of nameservers from
other sources, and that has been done to survey the state of the Internet,
that doesn't give the tester the contact details necessary to inform the
operators.  The SOA RNAME is often invalid and whois data is obscured and / or
not available which makes it infeasible for others to do this.
</t>
<t>While this section talks about TLD operators performing this work, it may be
done by registrars on behalf of the TLD operator.  The intent is to ensure
that the testing happens and that operators of non-compliant nameservers be
informed, rather than to prescribe who does the actual testing and
communication.  Note: having registrars perform this testing and reporting is
likely to result in duplicate reports for the same server being issued by
multiple registrars.
</t>
<t>TLD operators should construct a list of servers child zones are delegated to
along with a delegated zone name.  This name shall be the query name used to
test the server as it is supposed to exist.
</t>
<t>For each server the TLD operator shall make an SOA query of the delegated zone
name.  This should result in the SOA record being returned in the answer
section.  If the SOA record is not returned but some other response is
returned, this is a indication of a bad delegation and the TLD operator should
take whatever steps it normally takes to rectify a bad delegation.  If more
that one zone is delegated to the server, it should choose another zone until
it finds a zone which responds correctly or it exhausts the list of zones
delegated to the server.
</t>
<t>If the server fails to get a response to a SOA query, the TLD operator should
make an A query as some nameservers fail to respond to SOA queries but respond
to A queries.  If it gets no response to the A query, another delegated zone
should be queried for as some nameservers fail to respond to zones they are
not configured for.  If subsequent queries find a responding zone, all
delegation to this server need to be checked and rectified using the TLD's
normal procedures.
</t>
<t>Having identified a working &lt;server, query name&gt; tuple the TLD operator
should now check that the server responds to EDNS, Unknown Query Type and TCP
tests as described above.  If the TLD operator finds that server fails any of
the tests, the TLD operator shall take steps to inform the operator of the
server that they are running a faulty nameserver and that they need to take
steps to correct the matter.  The TLD operator shall also record the
&lt;server, query name&gt; for follow-up testing.
</t>
<t>If repeated attempts to inform and get the customer to correct / replace the
faulty server are unsuccessful the TLD operator shall remove all delegations
to said server from the zone.  Removal of delegations is the step of last
resort in handling complaints as specified in <xref target="RFC1033"/> COMPLAINTS.
</t>
<t>It will also be necessary for TLD operators to repeat the scans periodically.
It is recommended that this be performed monthly backing off to bi-annually
once the numbers of faulty servers found drops off to less than 1 in 100000
servers tested.  Follow-up tests for faulty servers still need to be performed
monthly.
</t>
<t>Some operators claim that they can't perform checks at registration time.  If
a check is not performed at registration time, it needs to be performed within
a week of registration in order to detect faulty servers swiftly.
</t>
<t>Checking of delegations by TLD operators should be nothing new as they have
been required from the very beginnings of DNS to do this <xref target="RFC1034"/>.  Checking
for compliance of nameserver operations should just be a extension of such
testing.
</t>
<t>It is recommended that TLD operators setup a test web page which performs the
tests the TLD operator performs as part of their regular audits to allow
nameserver operators to test that they have correctly fixed their servers.
Such tests should be rate limited to avoid these pages being a denial of
service vector.
</t>
<t>Nothing in this section precludes others testing servers for protocol
compliance.  DNS operators should test their servers to ensure that their
vendors have shipped protocol compliant products.  Nameserver vendors can use
these tests as a part of this release processes.  Registrants can use these
tests to check their DNS operators servers.
</t>
</section>

<section anchor="firewalls-and-load-balancers" title="Firewalls and Load Balancers">
<t>Firewalls and load balancers can affect the externally visible behaviour of a
nameserver.  Tests for conformance should to be done from outside of any
firewall so that the system as a whole is tested.
</t>
<t>Firewalls and load balancers should not drop DNS packets that they don't
understand.  They should either pass the packets or generate an appropriate
error response.
</t>
<t>Requests for unknown query types is normal client behaviour and should not be
construed as an attack.  Nameservers have always been expected to be able to
handle such queries.
</t>
<t>Requests for unknown query classes is normal client behaviour and should not
be construed as an attack.  Nameservers have always been expected to be able
to handle such queries.
</t>
<t>Requests with unknown opcodes is normal client behaviour and should not be
construed as an attack.  Nameservers have always been expected to be able to
handle such queries.
</t>
<t>Requests with unassigned flags set (DNS or EDNS) is expected client behaviour
and should not be construed as an attack.  The behaviour for unassigned flags
is to ignore them in the request and to not set them in the response.
Dropping DNS / EDNS packets with unassigned flags makes it difficult to deploy
extensions that make use of them due to the need to reconfigure and update
firewalls.
</t>
<t>Requests with unknown EDNS options is expected client behaviour and should not
be construed as an attack.  The correct behaviour for unknown EDNS options is
to ignore there presence when constructing a reply.
</t>
<t>Requests with unknown EDNS versions is expected client behaviour and should
not be construed as an attack.  The correct behaviour for unknown EDNS
versions is to return BADVERS along with the highest EDNS version the server
supports.  Dropping EDNS packet breaks EDNS version negotiation.
</t>
<t>Firewalls should not assume that there will only be a single response message
to a requests.  There have been proposals to use EDNS to signal that multiple
DNS messages be returned rather than a single UDP message that is fragmented
at the IP layer.
</t>
<t>However, there may be times when a nameserver mishandles messages with a
particular flag, EDNS option, EDNS version field, opcode, type or class field
or combination there of to the point where the integrity of the nameserver is
compromised.  Firewalls should offer the ability to selectively reject
messages with an appropriately constructed response based on all these fields
while awaiting a fix from the nameserver vendor.
</t>
<t>DNS and EDNS in particular is designed to allow clients to be able to use new
features against older servers without having to validate every option.
Indiscriminate blocking of messages breaks that design.
</t>
</section>

<section anchor="scrubbing-services" title="Scrubbing Services">
<t>Scrubbing services, like firewalls, can affect the externally visible
behaviour of a nameserver.  If a operator uses a scrubbing service, they
should check that legitimate queries are not being blocked.
</t>
<t>Scrubbing services, unlike firewalls, are also turned on and off in response
to denial of service attacks.  One needs to take care when choosing a
scrubbing service and ask questions like mentioned above.
</t>
<t>Ideally, Operators should run these tests against a scrubbing service to
ensure that these tests are not seen as attack vectors.
</t>
</section>

<section anchor="whole-answer-caches" title="Whole Answer Caches">
<t>Whole answer caches take a previously constructed answer and return it to a
subsequent query for the same qname, qtype and qclass, just updating the query
id field and possibly the qname to match the incoming query to avoid
constructing each response individually.
</t>
<t>Whole answer caches can return the wrong response to a query if they do not
take all of the attributes of the query into account, rather than just some of
them e.g. qname, qtype and qclass.  This has implications when testing and
with overall protocol compliance.
</t>
<t>Two current examples are:
</t>
<t>
<list style="symbols">
<t>Whole answer caches that ignore the EDNS version field which results in
 incorrect answers to non EDNS version 0 queries being returned if they
 were preceded by a EDNS version 0 query for the same name and type.</t>
<t>Whole answer caches that ignore the EDNS options in the query resulting
 in options only working some of the time and/or options being returned
 when not requested.</t>
</list>
</t>
</section>

<section anchor="response-code-selection" title="Response Code Selection">
<t>Choosing the correct response code when responding to DNS queries is
important.  Just because a DNS qtype is not implemented does not mean that
NOTIMP is the correct response code to return.  Response codes should be
chosen considering how clients will handle them.
</t>
<t>For unimplemented opcodes NOTIMP is the expected response code.  For example,
a new opcode could change the message format by extending the header or
changing the structure of the records etc.  This may result in FORMERR being
returned though NOTIMP would be more correct.
</t>
<t>Unimplemented type codes, Name Error (NXDOMAIN) and NOERROR (no data) are the
expected response codes.  A server is not supposed to serve a zone which
contains unsupported types (<xref target="RFC1034"/>) so the only thing left is return if
the QNAME exists or not.  NOTIMP and REFUSED are not useful responses as they
force the clients to try the other authoritative servers for a zone looking
for a server which will answer the query.
</t>
<t>Meta queries may be the exception but these need to be thought about on a case
by case basis.
</t>
<t>If the server supports EDNS and receives a query with an unsupported EDNS
version, the correct response is BADVERS <xref target="RFC6891"/>.
</t>
<t>If the server does not support EDNS at all, FORMERR and NOTIMP are the
expected error codes.  That said a minimal EDNS server implementation requires
parsing the OPT records and responding with an empty OPT record.  There is no
need to interpret any EDNS options present in the request as unsupported EDNS
options are expected to be ignored <xref target="RFC6891"/>.
</t>
</section>

<section anchor="testing" title="Testing">
<t>Testing is divided into two sections.  Basic DNS which all servers should meet
and Extended DNS which should be met by all servers that support EDNS (a
server is deemed to support EDNS if it gives a valid EDNS response to any EDNS
query).  If a server does not support EDNS it should still respond to all the
tests.
</t>
<t>It is advisable to run all of the tests below in parallel so as to minimise
the delays due to multiple timeouts when the servers do not respond.  There
are 16 queries directed to each nameserver assuming no packet loss testing
different aspects of Basic DNS and EDNS.
</t>
<t>The tests below use dig from BIND 9.11.0 which is still in development.
</t>

<section anchor="testing--basic-dns" title="Testing - Basic DNS">
<t>This first set of tests cover basic DNS server behaviour and all servers
should pass these tests.
</t>

<section anchor="is-the-server-configured-for-the-zone" title="Is The Server Configured For The Zone?">
<t>Verify the server is configured for the zone:
</t>

<figure align="center"><artwork align="center">
dig +noedns +noad +norec soa $zone @$server

expect: status: NOERROR
expect: SOA record
expect: flag: aa to be present
</artwork></figure>
</section>

<section anchor="testing-unknown-types" title="Testing Unknown Types?">
<t>Check that queries for an unknown type work:
</t>

<figure align="center"><artwork align="center">
dig +noedns +noad +norec type1000 $zone @$server

expect: status: NOERROR
expect: an empty answer section.
expect: flag: aa to be present
</artwork></figure>
<t>That new types are to be expected is specified in Section 3.6,
<xref target="RFC1035"/>.  Servers that don't support a new type are expected to reject a
zone that contains a unsupported type as per Section 5.2, <xref target="RFC1035"/>.  This
means that a server that does load a zone can answer questions for unknown
types with NOERROR or NXDOMAIN as per Section 4.3.2, <xref target="RFC1034"/>. <xref target="RFC6895"/>
later reserved distinct ranges for meta and data types which allows servers to
be definitive about whether a query should be answerable from zone content or
not.
</t>
</section>

<section anchor="testing-header-bits" title="Testing Header Bits">

<section anchor="testing-cd1-queries" title="Testing CD=1 Queries">
<t>Check that queries with CD=1 work:
</t>

<figure align="center"><artwork align="center">
dig +noedns +noad +norec +cd soa $zone @$server

expect: status: NOERROR
expect: SOA record to be present
expect: flag: aa to be present
</artwork></figure>
<t>CD use in queries is defined in <xref target="RFC4035"/>.
</t>
</section>

<section anchor="testing-ad1-queries" title="Testing AD=1 Queries">
<t>Check that queries with AD=1 work:
</t>

<figure align="center"><artwork align="center">
dig +noedns +norec +ad soa $zone @$server

expect: status: NOERROR
expect: SOA record to be present
expect: flag: aa to be present
</artwork></figure>
<t>AD use in queries is defined in <xref target="RFC6840"/>.
</t>
</section>

<section anchor="testing-reserved-bit" title="Testing Reserved Bit">
<t>Check that queries with the last unassigned DNS header flag work and that the
flag bit is not copied to the response:
</t>

<figure align="center"><artwork align="center">
dig +noedns +noad +norec +zflag soa $zone @$server

expect: status: NOERROR
expect: SOA record to be present
expect: MBZ to not be in the response
expect: flag: aa to be present
</artwork></figure>
<t>MBZ (Must Be Zero) presence indicates the flag bit has been incorrectly
copied.  See Section 4.1.1, <xref target="RFC1035"/> &quot;Z Reserved for future use.  Must be
zero in all queries and responses.&quot;
</t>
</section>
</section>

<section anchor="testing-unknown-opcodes" title="Testing Unknown Opcodes">
<t>Check that new opcodes are handled:
</t>

<figure align="center"><artwork align="center">
dig +noedns +noad +opcode=15 +norec +header-only @$server

expect: status: NOTIMP
expect: SOA record to not be present
expect: flag: aa to NOT be present
</artwork></figure>
<t>As unknown opcodes have no definition, including packet format other than
there must be a DNS header present, there is only one possible rcode that make
sense to return to a request with a unknown opcode and that is NOTIMP.
</t>
</section>

<section anchor="testing-tcp" title="Testing TCP">
<t>Check that TCP queries work:
</t>

<figure align="center"><artwork align="center">
dig +noedns +noad +norec +tcp soa $zone @$server

expect: status: NOERROR
expect: SOA record
expect: flag: aa to be present
</artwork></figure>
<t>The requirement that TCP be supported is defined in <xref target="RFC7766"/>.
</t>
</section>
</section>

<section anchor="testing--extended-dns" title="Testing - Extended DNS">
<t>The next set of test cover various aspects of EDNS behaviour.  If any of these
tests succeed, then all of them should succeed.  There are servers that
support EDNS but fail to handle plain EDNS queries correctly so a plain EDNS
query is not a good indicator of lack of EDNS support.
</t>

<section anchor="testing-minimal-edns" title="Testing Minimal EDNS">
<t>Check that plain EDNS queries work:
</t>

<figure align="center"><artwork align="center">
dig +nocookie +edns=0 +noad +norec soa $zone @$server

expect: status: NOERROR
expect: SOA record to be present
expect: OPT record to be present
expect: EDNS Version 0 in response
expect: flag: aa to be present
</artwork></figure>
<t>+nocookie disables sending a EDNS COOKIE option in which is on by default.
</t>
</section>

<section anchor="testing-edns-version-negotiation" title="Testing EDNS Version Negotiation">
<t>Check that EDNS version 1 queries work (EDNS supported):
</t>

<figure align="center"><artwork align="center">
dig +nocookie +edns=1 +noednsneg +noad +norec soa $zone @$server

expect: status: BADVERS
expect: SOA record to not be present
expect: OPT record to be present
expect: EDNS Version 0 in response
expect: flag: aa to NOT be present
</artwork></figure>
<t>Only EDNS Version 0 is currently defined so the response should always be a 0
version. This will change when EDNS version 1 is defined.  BADVERS is the
expected rcode if EDNS is supported as per Section 6.1.3, <xref target="RFC6891"/>.
</t>
</section>

<section anchor="testing-unknown-edns-options" title="Testing Unknown EDNS Options">
<t>Check that EDNS queries with an unknown option work (EDNS supported):
</t>

<figure align="center"><artwork align="center">
dig +nocookie +edns=0 +noad +norec +ednsopt=100 soa $zone @$server

expect: status: NOERROR
expect: SOA record to be present
expect: OPT record to be present
expect: OPT=100 to not be present
expect: EDNS Version 0 in response
expect: flag: aa to be present
</artwork></figure>
<t>Unknown EDNS options are supposed to be ignored, Section 6.1.2, <xref target="RFC6891"/>.
</t>
</section>

<section anchor="testing-unknown-edns-flags" title="Testing Unknown EDNS Flags">
<t>Check that EDNS queries with unknown flags work (EDNS supported):
</t>

<figure align="center"><artwork align="center">
dig +nocookie +edns=0 +noad +norec +ednsflags=0x40 soa $zone @$server

expect: status: NOERROR
expect: SOA record to be present
expect: OPT record to be present
expect: MBZ not to be present
expect: EDNS Version 0 in response
expect: flag: aa to be present
</artwork></figure>
<t>MBZ (Must Be Zero) presence indicates the flag bit has been incorrectly copied
as per Section 6.1.4, <xref target="RFC6891"/>.
</t>
</section>

<section anchor="testing-edns-version-negotiation-with-unknown-edns-flags" title="Testing EDNS Version Negotiation With Unknown EDNS Flags">
<t>Check that EDNS version 1 queries with unknown flags work (EDNS supported):
</t>

<figure align="center"><artwork align="center">
dig +nocookie +edns=1 +noednsneg +noad +norec +ednsflags=0x40 soa \
    $zone @$server

expect: status: BADVERS
expect: SOA record to NOT be present
expect: OPT record to be present
expect: MBZ not to be present
expect: EDNS Version 0 in response
expect: flag: aa to NOT be present
</artwork></figure>
<t>+noednsneg disables EDNS version negotiation in DiG; MBZ (Must Be Zero)
presence indicates the flag bit has been incorrectly copied.
</t>
</section>

<section anchor="testing-edns-version-negotiation-with-unknown-edns-options" title="Testing EDNS Version Negotiation With Unknown EDNS Options">
<t>Check that EDNS version 1 queries with unknown options work (EDNS supported):
</t>

<figure align="center"><artwork align="center">
dig +nocookie +edns=1 +noednsneg +noad +norec +ednsopt=100 soa \
    $zone @$server

expect: status: BADVERS
expect: SOA record to NOT be present
expect: OPT record to be present
expect: OPT=100 to NOT be present
expect: EDNS Version 0 in response
expect: flag: aa to be present
</artwork></figure>
<t>+noednsneg disables EDNS version negotiation in DiG.
</t>
</section>

<section anchor="testing-dnssec-queries" title="Testing DNSSEC Queries">
<t>Check that a DNSSEC queries work (EDNS supported):
</t>

<figure align="center"><artwork align="center">
dig +nocookie +edns=0 +noad +norec +dnssec soa $zone @$server

expect: status: NOERROR
expect: SOA record to be present
expect: OPT record to be present
expect: DO=1 to be present if a RRSIG is in the response
expect: EDNS Version 0 in response
expect: flag: aa to be present
</artwork></figure>
<t>DO=1 should be present if RRSIGs are returned as they indicate that the server
supports DNSSEC.  Servers that support DNSSEC are supposed to copy the DO bit
from the request to the response as per <xref target="RFC3225"/>.
</t>
</section>

<section anchor="testing-edns-version-negotiation-with-dnssec" title="Testing EDNS Version Negotiation With DNSSEC">
<t>Check that EDNS version 1 DNSSEC queries work (EDNS supported):
</t>

<figure align="center"><artwork align="center">
dig +nocookie +edns=1 +noednsneg +noad +norec +dnssec soa \
    $zone @$server

expect: status: BADVERS
expect: SOA record to not be present
expect: OPT record to be present
expect: DO=1 to be present if the EDNS version 0 DNSSEC query test
        returned DO=1
expect: EDNS Version 0 in response
expect: flag: aa to NOT be present
</artwork></figure>
<t>+noednsneg disables EDNS version negotiation in DiG.
</t>
</section>

<section anchor="testing-with-multiple-defined-edns-options" title="Testing With Multiple Defined EDNS Options">
<t>Check that EDNS queries with multiple defined EDNS options work:
</t>

<figure align="center"><artwork align="center">
dig +edns=0 +noad +norec +cookie +nsid +expire +subnet=0.0.0.0/0 \
    soa $zone @$server

expect: status: NOERROR
expect: SOA record to be present
expect: OPT record to be present
expect: EDNS Version 0 in response
expect: flag: aa to be present
</artwork></figure>
</section>
</section>

<section anchor="when-edns-is-not-supported" title="When EDNS Is Not Supported">
<t>If EDNS is not supported by the nameserver, we expect a response to all the
above queries.  That response may be a FORMERR or NOTIMP error response or the
OPT record may just be ignored.
</t>
<t>Some nameservers only return a EDNS response when a particular EDNS option or
flag (e.g. DO=1) is present in the request. This behaviour is not compliant
behaviour and may hide other incorrect behaviour from the above tests.
Re-testing with the triggering option / flag present will expose this
misbehaviour.
</t>
</section>
</section>

<section anchor="security-considerations" title="Security Considerations">
<t>Testing protocol compliance can potentially result in false reports of
attempts to break services from Intrusion Detection Services and firewalls.
None of the tests listed above should break nominally EDNS compliant servers.
None of the tests above should break non EDNS servers.  All the tests above
are well formed, though not necessarily common, DNS queries.
</t>
<t>Relaxing firewall settings to ensure EDNS compliance could potentially expose
a critical implementation flaw in the nameserver.  Nameservers should be
tested for conformance before relaxing firewall settings.
</t>
<t>When removing delegations for non-compliant servers there can be a knock on
effect on other zones that require these zones to be operational for the
nameservers addresses to be resolved.
</t>
</section>

<section anchor="iana-considerations" title="IANA Considerations">
<t>There are no actions for IANA.
</t>
</section>

</middle>
<back>
<references title="Normative References">
<?rfc include="http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.1034.xml"?>
<?rfc include="http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.1035.xml"?>
<?rfc include="http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.3225.xml"?>
<?rfc include="http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.4035.xml"?>
<?rfc include="http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.6840.xml"?>
<?rfc include="http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.6891.xml"?>
<?rfc include="http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.6895.xml"?>
<?rfc include="http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7766.xml"?>
</references>
<references title="Informative References">
<?rfc include="http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.1033.xml"?>
</references>

<section anchor="document-source" title="Document Source">
<t><list style="empty">
<t>[RFC Editor: Please remove this section before publication.]
</t>
</list></t>
<t>This document is maintained at Github at
<eref target="https://github.com/mpounsett/no-response-issue"/>.  Issue reports and pull
requests are gratefully accepted here.
</t>
<t>The XML and TXT versions of this document are generated from Markdown
using mmark by Miek Gieben.  mmark is available at
<eref target="https://github.com/miekg/mmark"/>.
</t>
</section>

</back>
</rfc>
